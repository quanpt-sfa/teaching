from ..utils.fuzzy import fuzzy_eq
from ..utils.normalizer import canonical
from ..utils.embedding_helper import col_vec
import numpy as np
from rapidfuzz import fuzz
from scipy.optimize import linear_sum_assignment
from .type_check import same_type

CODE_KEYWORDS = ("ma", "code", "id", "sohieu", "phieu", "voucher")
TYPE_FAMILY = {
    'char':'str','varchar':'str','nvarchar':'str',
    'nchar':'str',
    'int':'int','bigint':'int','smallint':'int',
    'decimal':'num','numeric':'num','money':'num','real':'num','float':'num',
    'date':'dt','datetime':'dt','smalldatetime':'dt'
}

def is_code_column(col_name: str) -> bool:
    name = col_name.lower()
    return any(name.startswith(k) or name.endswith(k) for k in CODE_KEYWORDS)

def phase2_one(ans_tbl, stu_tbl, ans_schema, stu_schema):
    """Ghép cột cho một cặp bảng đã cố định (hai bước + 70/30).
    
    Args:
        ans_tbl: Tên bảng đáp án
        stu_tbl: Tên bảng sinh viên hoặc None
        ans_schema: Schema đáp án
        stu_schema: Schema sinh viên
    
    Returns:
        list: Các dòng kết quả ghép cột
    """
    ans_cols = ans_schema[ans_tbl]['cols']
    if stu_tbl is None:
        return [[ans_tbl, c, d, "—", "—", "—", 0.0, False] for c, d in ans_cols]

    stu_cols = stu_schema[stu_tbl]['cols']
    if not ans_cols or not stu_cols:
        return [[ans_tbl, c, d, stu_tbl, "—", "—", 0.0, False] for c, d in ans_cols]

    # Bước 1: name-match trực tiếp
    matched_idx_stu = set()
    rows = []
    for i, (cA, tA) in enumerate(ans_cols):
        hit = None
        for j, (cS, tS) in enumerate(stu_cols):
            if j in matched_idx_stu:  # đã dùng
                continue
            if canonical(cA) == canonical(cS):  # trùng/alias
                ok = same_type(tA, tS, cA, cS)
                score = 1.0 if ok else 0.0
                rows.append([ans_tbl, cA, tA, stu_tbl, cS, tS, score, ok])
                matched_idx_stu.add(j)
                hit = True
                break
        if hit is None:
            rows.append([ans_tbl, cA, tA, None, None, None, None, None])

    # Bước 2: 70% cosine + 30% token cho các cột còn lại
    needA = [r for r in rows if r[6] is None]
    needB = [(j, *stu_cols[j]) for j in range(len(stu_cols)) if j not in matched_idx_stu]    if needA and needB:
        # Chuyển tên cột thành vectors
        vecA = np.stack([col_vec(r[1]) for r in needA])
        vecB = np.stack([col_vec(c) for _, c, _ in needB])
        vecA = np.atleast_2d(vecA)
        vecB = np.atleast_2d(vecB)
        
        # Cosine similarity
        cos = vecA @ vecB.T
        cos /= (np.linalg.norm(vecA, axis=1)[:, None] + 1e-8)
        cos /= (np.linalg.norm(vecB, axis=1)[None, :] + 1e-8)
        
        # Token overlap không dùng nữa vì đã tích hợp vào điều kiện ok
        score = cos  # Chỉ dùng cosine similarity
        cost = -score
        r_idx, c_idx = linear_sum_assignment(cost)
        
        # Cập nhật kết quả với điều kiện mới
        for i,j in zip(r_idx,c_idx):
            if score[i, j] <= 0:
                continue
            idx_stu, cS, tS = needB[j]
            cA, tA = needA[i][1:3]
            # Điều kiện mới: cosine >= 0.75 hoặc token_set_ratio = 100
            ok = (score[i, j] >= 0.75 or 
                  fuzz.token_set_ratio(canonical(cA), canonical(cS)) == 100) \
                and same_type(tA, tS, cA, cS)
            rows_id = rows.index(needA[i])
            rows[rows_id] = [ans_tbl, cA, tA, stu_tbl, cS, tS, float(score[i, j]), ok]
      # Điền các cột chưa ghép được
    for r in rows:
        if r[6] is None:
            r[3:] = [stu_tbl, "—", "—", 0.0, False][:]
    
    return rows

def match_all_pairs(ans_schema, stu_schema, mapping, COL_TH=0.82):
    """Ghép cặp toàn bộ cột giữa hai schema."""
    ans_tbls = list(ans_schema.keys())
    stu_tbls = list(stu_schema.keys())
    ans_items = [(t, c, d) for t, m in ans_schema.items() for c, d in m['cols']]
    stu_items = [(t, c, d) for t, m in stu_schema.items() for c, d in m['cols']]
    m, n = len(ans_items), len(stu_items)
    if m == 0 or n == 0:
        return [], 0.0, [], [], None    # Convert column names to vectors using col_vec
    vA = np.stack([col_vec(it[1]) for it in ans_items])  # Use col_vec with just column name
    vB = np.stack([col_vec(it[1]) for it in stu_items])  # Use col_vec with just column name
    sim = vA @ vB.T
    sim /= np.linalg.norm(vA, axis=1, keepdims=True)
    sim /= np.linalg.norm(vB, axis=1, keepdims=True).T
    size = max(m, n)
    cost = np.full((size, size), 1e3)
    cost[:m, :n] = -sim
    row, col = linear_sum_assignment(cost)
    pairs, correct = [], 0
    for i, j in zip(row, col):
        if i >= m or j >= n:
            continue
        tA, cA, dA = ans_items[i]
        tS, cS, dS = stu_items[j]
        score = sim[i, j]
        ok = score >= COL_TH and dA.lower() == dS.lower()
        if ok:
            correct += 1
        pairs.append({
            "AnsTbl": tA, "AnsCol": cA, "AnsType": dA,
            "StuTbl": tS, "StuCol": cS, "StuType": dS,
            "Cos": float(score), "Match": ok
        })
    ratio = correct / m
    return pairs, ratio, ans_tbls, stu_tbls, None
